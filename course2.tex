% !TeX spellcheck = ru_RU
\documentclass[a4paper,14pt]{extarticle}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{hyperref}

\usepackage{xcolor}

\usepackage{indentfirst}
\usepackage[left = 20mm, right = 10mm, top = 20mm, bottom = 20mm]{geometry}
\usepackage[indent=1.25cm]{parskip}
\renewcommand{\baselinestretch}{1.5}

\newtheorem{theorem}{Теорема}

\lstset{label=Листинг, tabsize = 2, basicstyle=\ttfamily, captionpos=b, escapeinside={№}{/№}}

\author{Борисенков Никита}



\begin{document}

\begin{titlepage}
    \newpage
    \begin{center}
        Московский государственный университет имени M.В. Ломоносова
        Механико-математический факультет\\
        Кафедра вычислительной математики \\
    \end{center}

    \vspace{8em}

    \begin{center}
        \Large Курсовая работа \\
    \end{center}

    \vspace{2em}

    \begin{center}
        \textsc{\textbf{}}
    \end{center}

    \vspace{20em}



    \newbox{\lbox}
    \newlength{\maxl}
    \setlength{\maxl}{\wd\lbox}
    \hfill\parbox{13cm}{
        \hspace*{5cm}\hspace*{-5cm}Студент: \qquad\qquad\hbox to \maxl{Борисенков Никита Николаевич\hfill}\\
        \hspace*{5cm}\hspace*{-5cm}Преподаватель: \hbox to \maxl{ С.н.с Кривчиков Максим Александрович}\\
        \\
        \hspace*{5cm}\hspace*{-5cm}Группа:\qquad\qquad $\;\:$ \hbox to\maxl{410}\\
    }


    \vspace{\fill}

    \begin{center}
        Москва \\2025
    \end{center}

\end{titlepage}
\newpage

\section*{Введение}

В данной работе описан процесс создания системы выделения регистров для
минималистичного низкоуровневого языка с опциональной типизацией FCLang, предложенного в \cite{____2023}.
В этом языке предполагается, что программист имеет прямой контроль над количеством инструкций, как в языках ассемблера.
Один из вариантов его использования -- это расширение языка Python, позволяющее внутри обычных программ на Python 
добавлять блоки кода написанные на языке FCLang, которые буду скомпилированы на лету. 
Это позволит в программе, написанной на высокоуровневом и медленном языке, <<горячие>> места писать на низкоуровневом быстром языке.

В языке FCLang одновременно с явно указанными регистрами присутствуют переменные, которые должны вести себя как регистры.
В процессе компиляции переменным сопоставляются регистры.
Задача нахождения допустимого сопоставления называется задачей выделения регистров.

В вопросе выделения регистров важно понятие времени жизни переменной.
Время жизни переменной -- это те команды, в моменты исполнения которых значение переменной должно оставаться доступно.
Обычно на командах программы есть какой-то порядок и время жизни принимает вид интервала или набора интервалов, в которых переменная жива.

В обычных языках программирования переменных может быть практически неограниченное количество, а число регистров жёстко ограничено целевой архитектурой процессора.
В таких популярных архитектурах как ARM64 и x86-64, число доступных физических регистров составляет 32 и 16 (если не считать векторные).
Если одновременно живо слишком много переменных, например больше, чем число физических регистров,
то часть из них приходится выносить из регистров в память компьютера.
Обычно -- на стек.
В некоторых случаях бывает возможно обойтись без обращения к памяти, но с перемещением значения из одного регистра в другой.
В обоих случаях, требуется добавление дополнительных инструкций, что увеличивает размер итоговой программы и может увеличить время её исполнения.
По этой причине в языке FCLang, если переменные не удаётся напрямую сопоставить с регистрами, то компилятор завершит своё исполнение с ошибкой.

\section{Результаты известных исследований}

При сравнении разных алгоритмов выделения регистров часто говорят о качестве генерируемого кода.
Под качеством здесь подразумевается время исполнения итоговой программы и её размер.
Чем они меньше, тем более качественным считается сгенерированный код.

Задача выделения регистров является важной частью процесса компиляции программ.
Самым известным способом решения этой задачи является сведение её к задаче раскраске графа пересечения времён жизни переменных.
Эта идея была предложена в 1981 году в \cite{chaitin_register_1981}.
Для произвольных графов задача раскраски является NP-сложной и в \cite{chaitin_register_1981} показано,
что для любого графа можно написать программу, задача выделения регистров которой будет сводиться к раскраске этого графа.

Для алгоритма, сформулированного в \cite{chaitin_register_1981} есть разные эвристики (например \cite{briggs_rematerialization_1992})
и модификации (например \cite{george_iterated_1996}), которые улучшают качество его работы, но основной сути его не меняют.

В статье \cite{hans_l_bodlaender_linear-time_1997} показано, что если число регистров фиксировано и не производится вынос переменных на стек,
то для <<структурированных>> программ существует линейный по количеству вершин и рёбер в графе алгоритм выделения регистров.
Структурированность в данной статье означает отсутствие команд перехода в произвольную точку программы.
Из структурированности следует ограниченная древесная ширина графов,
а для таких графов существует линейный алгоритм определения возможности и нахождения раскраски.
При этом сложность алгоритма получается экспоненциально зависящей от числа регистров,
которое для каждой конкретной архитектуры процессора фиксировано.

Другое развитие этого метода представлено в статье \cite{hutchison_register_2005}, 
авторы которой замечают, что графы большинства программ являются хордовыми.
А для хордовых графов существует линейный по числу рёбер алгоритм нахождения раскраски, который они и реализуют. 
Получившийся алгоритм не итеративный, в отличие от классического (а именно версии из \cite{george_iterated_1996}),
линейный в случае хордовых графов и по качеству кода сопоставим с классическим.

Алгоритмы, основанные на раскраске графов оптимальными в том смысле,
что если для программы возможно выделить регистры без выноса значений в память, то они это всегда сделают.
Рассмотренные дальше алгоритмы таким свойством не обладают, но при этом они всё ещё могут генерировать достаточно качественный код
и работают быстрее алгоритмов, основанных на раскраске.

Другой известный способ выделения регистров -- это линейное сканирование (linear scan), предложенный в статье \cite{poletto_linear_1999}.
Этот алгоритм не использует графовое представление пересечений интервалов жизни переменных, а работает с ними напрямую.
Сложность этого алгоритма линейна по количеству переменных, что является значительным преимуществом по сравнению с раскраской графа,
и позволяет его использовать в случаях, когда время компиляции важно (например, JIT-компиляция).
Основным недостатком является худшее, по сравнению с раскраской графа, качество генерируемого кода, то есть полученные программы работают медленнее.

В статье \cite{krishnamurthi_extended_2007} замечено, что задача выделения регистров не эквивалентна напрямую задаче раскраски графа.
Из последней следует первая, но не наоборот.
В добавок к этому авторы указывают на такие недостатки алгоритмов раскраски графа,
как нелинейность и необходимость выделять память для него,
пропорциональную в худшем случае $n^2$, а в среднем $n^{1,5}$, где $n$ -- это число переменных.
Авторы предлагают алгоритм, основанный на линейном сканировании, который этими недостатками не обладает.
Более того, этот алгоритм работает быстрее и в большинстве случаев, на которых авторы его проверяли, генерирует более качественный код.

На практике могут использоваться и другие алгоритмы.
Например, в компиляторе LLVM используется жадный алгоритм выделения регистров (greedy allocator) \cite{llvm_greedy_2011}.
Суть алгоритма заключается в выделении регистров в первую очередь под переменные с длинным интервалом жизни.
Когда какие-то переменные не попадают в регистры, интервалы жизни измельчаются, чтобы переменные с более короткими интервалами жизни могли попасть в получающиеся зазоры.


\section{Постановка задачи}

В настоящей работе основной задачей является написание системы выделения регистров для компилятора языка FCLang.
Для проверки работоспособности полученного алгоритма нужно было создать макет языка FCLang.

Программа на языке FCLang состоит из базовых блоков, которые содержат в себе линейные участки кода.
У каждого блока есть одна точка входа -- его начало.
В начале указываются переменные, которые используются как входные значения.
Точек выхода может быть несколько.
В каждой указываются условие при котором совершится переход, в какой блок совершается переход и какие переменные передаются в этот блок.

Внутри каждого блока находятся объявления переменных и инструкции.
Так же там могут находиться выражения на языке Python, который выступает в качестве макроязыка.
%В листинге \ref{syntax} представлен примерный синтаксис программы без конкретного описания всех выражений.
%
%\begin{lstlisting}[caption=Синтаксис программы на FCLang, label=syntax]
%<program>           №$\rightarrow$/№ <block declaration>№$^{*}$/№ <block>№$^{*}$/№
%<block>             №$\rightarrow$/№ <block start> <block part>№$^{*}$/№ <block exit>
%<block start>       №$\rightarrow$/№ <block begin> <variable as input>№$^{*}$/№
%<block exit>        №$\rightarrow$/№ pass_control <block name and variables to pass>
%<block part>        №$\rightarrow$/№ <variable definition> | <instruction> | <conditional exit>
%<conditional exit>  №$\rightarrow$/№ condition_pass <condition> <block name and variables to pass>
%\end{lstlisting}

Инструкции соответствуют командам ассемблера.
Для каких-то стандартных операций, например для системных вызовов, могут быть сделаны макроинструкции, которые создадут нужный набор инструкций сами.

Переменная в языке FCLang ведёт себя как регистр, который отличается от всех остальных переменных и регистров, используемых одновременно с ней.
При объявлении переменной можно явно указать какому регистру она соответствует.
Соответственно задача выделения регистров в этом языке должна быть решена без выноса переменных в память.
Если это нужно сделать, то это должен будет делать пользователь.

Для создания макета языка нужно написать компилятор, входными данными которого будет программа, написанная в каком-то виде,
а выходными -- код ассемблера, который дальше может быть собран в исполняемый файл.
В этой работе был использован ассемблер NASM и код генерировался для операционной системы Linux на архитектуре x86-64.

\section{Решение}
\subsection{Выбор алгоритма}

Для решения этой задачи был выбран алгоритм линейного сканирования.
Сделано это было по следующим причинам:
\begin{itemize}
    \item Скорость: этот алгоритм имеет линейную по числу переменных сложность, что позволит в дальнейшем использовать вставки на языке FCLang, компилируемые во время исполнения.
        При этом коэффициент линейной зависимости небольшой.
    \item Простота реализации: псевдокод самой простой версии этого алгоритма, представленный в \cite{poletto_linear_1999}, занимает всего 26 строк с выносом переменных на стек.
        Без выноса -- 16.
        При этом на язык Python этот код переписывается практически напрямую.
        Реализация в компиляторе FCLang сложнее, но не намного.
%    \item Глобальное выделение регитсров при помощи раскраски графов без дополнительной обработки входного кода могут давать выносы на память там, где можно обойтись без них.
%        Это было замечено в \cite{krishnamurthi_extended_2007}. Пример приведён в листинге \ref{clique_example}
    \item Граф программы, которую можно написать на языке FCLang может быть произвольным, 
        поэтому более простые алгоритмы, предложенные в \cite{hutchison_register_2005}, использовать не получится.
\end{itemize}

%\begin{lstlisting}
%switch {
%    case 0:     case 1:     case 2:
%    a = ...     b = ...     a = ...
%    b = ...     c = ...     c = ...
%    op(a, b)    op(b, c)    op(a, c)
%    break       break       break
%}
%№
%Считается, что доступных регистров 2.
%В случае глобального выделения раскраской графов a, b и c образуют клику и раскрасить её в 2 цвета нельзя.
%При этом выделить регистры можно.
%Все \texttt{case} образуют отдельные блоки и в каждом блоке живы только 2 переменные.
%/№
%\end{lstlisting}

\subsection{Уточнение алгоритма для задачи}

Алгоритм выделения регистров в этой задаче используется локальный и применяется для каждого блока отдельно.
Единственное исключение -- это переменные, используемые как входы или выходы блока.
Такие переменные между собой связаны и связанным переменным выделяется один и тот же регистр.

При выделении регистров надо учитывать не только другие переменные, но и явные использования регистров, а така же то, что некоторые инструкции (например div) могут менять конкретные регистры.
Все статьи, которые были рассмотрены при выполнении данной работы либо не упоминают это, либо в случае раскраски графов говорят, что это решается предраскрашиванием части вершин.
В этой работе эта проблема была решена добавлением для каждой переменной списка регистров, которые используются в её время жизни.
Для построения этого списка используется дополнительный проход по блоку.



\section{Заключение}

\newpage

\bibliographystyle{ugost2008}
\bibliography{fclang_register_allocation}


\end{document}
