% !TeX spellcheck = ru_RU
\documentclass[a4paper,14pt]{extarticle}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{hyperref}

\usepackage{xcolor}

\usepackage{indentfirst}
\usepackage[left = 20mm, right = 10mm, top = 20mm, bottom = 20mm]{geometry}
\usepackage[indent=1.25cm]{parskip}
\renewcommand{\baselinestretch}{1.5}

\newtheorem{theorem}{Теорема}

\lstset{label=Листинг, tabsize = 2, basicstyle=\ttfamily, captionpos=b, escapeinside={№}{/№}}

\author{Борисенков Никита}



\begin{document}

\begin{titlepage}
    \newpage
    \begin{center}
        Московский государственный университет имени M.В. Ломоносова
        Механико-математический факультет\\
        Кафедра вычислительной математики \\
    \end{center}

    \vspace{8em}

    \begin{center}
        \Large Курсовая работа \\
    \end{center}

    \vspace{2em}

    \begin{center}
        \textsc{\textbf{}}
    \end{center}

    \vspace{20em}



    \newbox{\lbox}
    \newlength{\maxl}
    \setlength{\maxl}{\wd\lbox}
    \hfill\parbox{13cm}{
        \hspace*{5cm}\hspace*{-5cm}Студент: \qquad\qquad\hbox to \maxl{Борисенков Никита Николаевич\hfill}\\
        \hspace*{5cm}\hspace*{-5cm}Преподаватель: \hbox to \maxl{ С.н.с Кривчиков Максим Александрович}\\
        \\
        \hspace*{5cm}\hspace*{-5cm}Группа:\qquad\qquad $\;\:$ \hbox to\maxl{410}\\
    }


    \vspace{\fill}

    \begin{center}
        Москва \\2025
    \end{center}

\end{titlepage}
\newpage

\section*{Введение}

В данной работе описан процесс создания системы выделения регистров для
минималистичного низкоуровневого языка с опциональной типизацией FCLang, предложенного в \cite{____2023}.
В этом языке предполагается, что программист имеет прямой контроль над количеством инструкций, как в языках ассемблера.
Один из вариантов его использования -- это расширение языка Python, позволяющее внутри обычных программ на Python 
добавлять блоки кода написанные на языке FCLang, которые буду скомпилированы на лету. 
Это позволит в программе, написаной на высокоуровневом и медленном языке,  <<горячие>> места писать на низкоуровневом быстром языке.

В языке FCLang одновременно с явно указанными регистрами присутствуют переменные, которые должны вести себя как регистры.
В процессе компиляции переменным сопоставляются регистры, задача нахождения допустимого сопоставления называется задачей выделения регистров.
Автоматический вынос на стек не производится, в случае невозможности выделения регистров, компилятор сообщает об этом пользователю

В вопросе выделения регистров важно понятие времени жизни переменной.
Время жизни переменной -- это те команды, в моменты исполнения которых значение переменной должно оставаться доступно.
Обычно на командах программы есть какой-то порядок и время жизни принимает вид интервала или набора интервалов, в которых переменная жива.

В обычных языках программирования переменных может быть практически неограниченное количество, а число регистров жёстко ограничено целевой архитектурой процессора.
В таких популярных архитектурах как ARM64 и x86-64, число доступных физических регистров составляет 32 и 16 (если не считать векторные).
Если одновременно живо слишком много переменных, например больше, чем число физических регистров,
то часть из них приходится выносить из регистров в память компьютера.
Обычно -- на стек.
В некоторых случаях бывает возможно обойтись без обращения к памяти, но с перемещением значения из одного регистра в другой.
В обоих случаях, требуется добавление дополнительных инструкций, что увеличивает размер итоговой программы и может увеличить время её исполнения.
По этой причине в языке FCLang, если переменные не удаётся напрямую сопоставить с регистрами, то компилятор завершит своё исполнение с ошибкой.

В связи с такими изменениями в генерируемом коде, которые могут вносить алгоритмы выделениия регистров, появляется идея качества генерируемого кода.
Она заключается в том, что чем быстрее и меньше получившаяся программа, тем выше качество.

\section{Результаты известных исследований}

Задача выделения регистров является важной частью процесса компиляции программ.
Самым известным способом решения этой задачи является сведение её к задаче раскраске графа пересечения времён жизни переменных.
Эта идея была предложена в 1981 году в \cite{chaitin_register_1981}.
Для произвольных графов задача раскраски является NP-сложной и в \cite{chaitin_register_1981} показано,
что для любого графа можно написать программу, задача выделения регистров которой будет сводиться к раскраске этого графа.

Для алгоритма, сформулированного в \cite{chaitin_register_1981} есть разные эвристики (например \cite{briggs_rematerialization_1992})
и модификации (например \cite{george_iterated_1996}), которые улучшают качество его работы, но основной сути его не меняют.

В статье \cite{hans_l_bodlaender_linear-time_1997} показано, что если число регистров фиксировано и не производится вынос переменных на стек,
то для <<структурированных>> программ существует линейный по количеству вершин и рёбер в графе алгоритм выделения регистров.
Структурированность в данной статье означает отсутствие команд перехода в произвольную точку программы.
Из структурированности следует ограниченная древесная ширина графов,
а для таких графов существует линейный алгоритм определения возможности и нахождения раскраски.
При этом сложность алгоритма получается экспоненциально зависящей от числа регистров,
которое для каждой конкретной архитектуры процессора фиксировано.

Другое развитие этого метода представлено в статье \cite{hutchison_register_2005}, 
авторы которой замечают, что графы большинства программ являются хордовыми.
А для хордовых графов существует линейный по числу рёбер алгоритм нахождения раскраски, который они и реализуют. 
Получившийся алгоритм не итеративный, в отличие от классического (а именно версии из \cite{george_iterated_1996}),
линейный в случае хордовых графов и по качеству кода сопоставим с классическим.

Алгоритмы, основанные на раскраске графов оптимальными в том смысле,
что если для программы возможно выделить регистры без выноса значений в память, то они это всегда сделают.
Рассмотренные дальше алгоритмы таким свойством не обладают, но при этом они всё ещё могут генерировать достаточно качественный код
и работают быстрее алгоритмов, основанных на раскраске.

Другой известный способ выделения регистров -- это линейное сканирование (linear scan), предложенный в статье \cite{poletto_linear_1999}.
Этот алгоритм не использует графовое представление пересечений интервалов жизни переменных, а работает с ними напрямую.
Сложность этого алгоритма линейна по количеству переменных, что является значительным преимуществом по сравнению с раскраской графа,
и позволяет его использовать в случаях, когда время компиляции важно (например, JIT-компиляция).
Основным недостатком является худшее, по сравнению с раскраской графа, качество генерируемого кода, то есть полученные программы работают медленнее.

В статье \cite{krishnamurthi_extended_2007} замечено, что задача выделения регистров не эквивалентна напрямую задаче раскраски графа.
Из последней следует первая, но не наоборот.
В добавок к этому авторы указывают на такие недостатки алгоритмов раскраски графа,
как нелинейность и необходимость выделять память для него,
пропорциональную в худшем случае $n^2$, а в среднем $n^{1,5}$, где n -- это число переменных.
Авторы предлагают алгоритм, основанный на линейном сканировании, который этими недостатками не обладает.
Более того, этот алгоритм работает быстрее и в большинстве случаев, на которых авторы его проверяли, генерирует более качественный код.

На практике могут использоваться и другие алгоритмы.
Например в компиляторе LLVM используется жадный алогоритм выделения регистров (greedy allocator) \cite{llvm_greedy_2011}.
Суть алгоритма заключается в выделении регистров в первую очередь под переменные с длинным интервалом жизни.
Когда какие-то переменные не попадат в регистры, интервалы жизни измельчаются, чтобы переменные с более короткими интервалами жизни могли попасть в получающиеся зазоры.


\section{Постановка задачи}

\section{Решение}

\section{Заключение}

\newpage

\bibliographystyle{ugost2008}
\bibliography{fclang_register_allocation}


\end{document}
