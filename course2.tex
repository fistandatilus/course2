% !TeX spellcheck = ru_RU
\documentclass[a4paper,14pt]{extarticle}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{hyperref}

\usepackage{xcolor}

\usepackage{indentfirst}
\usepackage[left = 20mm, right = 10mm, top = 20mm, bottom = 20mm]{geometry}
\usepackage[indent=1.25cm]{parskip}
\renewcommand{\baselinestretch}{1.5}

\newtheorem{theorem}{Теорема}

\lstset{label=Листинг, tabsize = 2, captionpos=b, escapeinside={№}{/№}, frame=single}

\author{Борисенков Никита}

\title{Создание системы выделения регистров для языка FCLang}

\begin{document}

\begin{titlepage}
    \newpage
    \begin{center}
        Московский государственный университет имени M.В. Ломоносова
        Механико-математический факультет\\
        Кафедра вычислительной математики \\
    \end{center}

    \vspace{8em}

    \begin{center}
        \Large Курсовая работа \\
    \end{center}

    \vspace{2em}

    \begin{center}
        \textsc{\textbf{Создание системы выделения регистров для языка FCLang}}
    \end{center}

    \vspace{20em}



    \newbox{\lbox}
    \newlength{\maxl}
    \setlength{\maxl}{\wd\lbox}
    \hfill\parbox{13cm}{
        \hspace*{5cm}\hspace*{-5cm}Студент: \qquad\qquad\hbox to \maxl{Борисенков Никита Николаевич\hfill}\\
        \hspace*{5cm}\hspace*{-5cm}Преподаватель: \hbox to \maxl{ С.н.с Кривчиков Максим Александрович}\\
        \\
        \hspace*{5cm}\hspace*{-5cm}Группа:\qquad\qquad $\;\:$ \hbox to\maxl{410}\\
    }


    \vspace{\fill}

    \begin{center}
        Москва \\2025
    \end{center}

\end{titlepage}
\newpage

\section*{Введение}

В данной работе описан процесс создания системы выделения регистров для
макета минималистичного низкоуровневого языка с опциональной типизацией FCLang, предложенного в \cite{____2023}.
В этом языке предполагается, что программист имеет прямой контроль над количеством инструкций, как в языках ассемблера.
Один из вариантов его использования -- это расширение языка Python, позволяющее внутри обычных программ на Python 
добавлять блоки кода написанные на языке FCLang, которые буду скомпилированы в процессе исполнения, перед первым использованием.
Такой на способ компиляции называют компиляцией на лету (just in time compilation, JIT).
Такой способ компиляции позволит в программе, написанной на высокоуровневом медленном интерпретируемом языке, <<горячие>> места писать на низкоуровневом быстром языке.

В языке FCLang одновременно с явно указанными регистрами присутствуют переменные, которые должны вести себя как регистры.
В процессе компиляции переменным сопоставляются регистры.
Задача нахождения допустимого сопоставления называется задачей выделения регистров.

В вопросе выделения регистров важно понятие времени жизни переменной.
Время жизни переменной -- это те команды, в моменты исполнения которых значение переменной должно оставаться доступно.
Обычно на командах программы есть какой-то порядок.
Например, тот, в котором они записаны.
Время жизни переменной тогда принимает вид интервала или набора интервалов.

В обычных языках программирования переменных может быть практически неограниченное количество, а число регистров жёстко ограничено целевой архитектурой процессора.
В таких популярных архитектурах как ARM64 и x86-64, число доступных физических регистров составляет 32 и 16 (если не считать векторные).
Если одновременно живо слишком много переменных, например больше, чем число физических регистров,
то часть из них приходится выносить из регистров в память компьютера.
Обычно они добавляются в конец стека.
В некоторых случаях бывает возможно обойтись без обращения к памяти, но с перемещением значения из одного регистра в другой.
В обоих случаях, требуется добавление дополнительных инструкций, что увеличивает размер итоговой программы и может увеличить время её исполнения.
По этой причине в языке FCLang, если переменные не удаётся напрямую сопоставить с регистрами, то компилятор завершит своё исполнение с ошибкой.

\section{Результаты известных исследований}

При сравнении разных алгоритмов выделения регистров целевой характеристикой является качество генерируемого кода.
В зависимости от режима компиляции и задач, качество можно оценивать по-разному.
Важными могут быть размер генерируемого кода и время его исполнения.

Задача выделения регистров является важной частью процесса компиляции программ.
Самым известным способом решения этой задачи является сведение её к задаче раскраске графа пересечения времён жизни переменных.
Эта идея была предложена в 1981 году в \cite{chaitin_register_1981}.
Для произвольных графов задача раскраски является NP-сложной и в \cite{chaitin_register_1981} показано,
что для любого графа можно написать программу, задача выделения регистров которой будет сводиться к раскраске этого графа.

Для алгоритма, сформулированного в \cite{chaitin_register_1981} есть разные эвристики (например \cite{briggs_rematerialization_1992})
и модификации (например \cite{george_iterated_1996}), которые улучшают качество его работы, но основной сути его не меняют.

В статье \cite{hans_l_bodlaender_linear-time_1997} показано, что если число регистров фиксировано и не производится вынос переменных на стек,
то для <<структурированных>> программ существует линейный по количеству вершин и рёбер в графе алгоритм выделения регистров.
Структурированность в данной статье означает отсутствие команд перехода в произвольную точку программы.
Из структурированности следует ограниченная древесная ширина графов,
а для таких графов существует линейный алгоритм определения возможности и нахождения раскраски.
При этом сложность алгоритма получается экспоненциально зависящей от числа регистров,
которое для каждой конкретной архитектуры процессора фиксировано.

Другое развитие этого метода представлено в статье \cite{hutchison_register_2005}, 
авторы которой замечают, что графы большинства программ являются хордовыми.
А для хордовых графов существует линейный по числу рёбер алгоритм нахождения раскраски, который они и реализуют. 
Получившийся алгоритм не итеративный, в отличие от классического (а именно версии из \cite{george_iterated_1996}),
линейный в случае хордовых графов и по качеству кода сопоставим с классическим.

Алгоритмы, основанные на раскраске графов являются оптимальными в том смысле,
что если для программы возможно выделить регистры без выноса значений в память, то они это всегда сделают.
Рассмотренные дальше алгоритмы таким свойством не обладают, но при этом они всё ещё могут генерировать достаточно качественный код
и работают быстрее алгоритмов, основанных на раскраске.

Наиболее известной альтернативой раскраске графов является алгоритм линейного сканирования (linear scan), предложенный в статье \cite{poletto_linear_1999}.
Этот алгоритм не использует графовое представление пересечений интервалов жизни переменных, а работает с ними напрямую.
Сложность этого алгоритма линейна по количеству переменных, что является значительным преимуществом по сравнению с раскраской графа,
и позволяет его использовать в случаях, когда время компиляции важно (например, JIT-компиляция).
Основным недостатком является худшее, по сравнению с раскраской графа, качество генерируемого кода, то есть полученные программы работают медленнее.

В статье \cite{krishnamurthi_extended_2007} замечено, что задача выделения регистров не эквивалентна напрямую задаче раскраски графа.
Из последней следует первая, но не наоборот.
Вдобавок к этому авторы указывают на такие недостатки алгоритмов раскраски графа,
как нелинейность и необходимость выделять память для него,
пропорциональную в худшем случае $n^2$, а в среднем $n^{1,5}$, где $n$ -- это число переменных.
Авторы предлагают алгоритм, основанный на линейном сканировании, который этими недостатками не обладает.
Более того, этот алгоритм работает быстрее и в большинстве случаев, на которых авторы его проверяли, генерирует более качественный код.

На практике могут использоваться и другие алгоритмы.
Например, в широко распространённом компиляторе LLVM используется жадный алгоритм выделения регистров (greedy allocator) \cite{llvm_greedy_2011}.
Суть алгоритма заключается в выделении регистров в первую очередь под переменные с длинным интервалом жизни.
Когда какие-то переменные не попадают в регистры, интервалы жизни измельчаются, чтобы переменные с более короткими интервалами жизни могли попасть в получающиеся зазоры.


\section{Постановка задачи}

В настоящей работе основной задачей является написание системы выделения регистров для макета компилятора языка FCLang.
Для проверки работоспособности полученного алгоритма нужно было создать макет языка FCLang.

Формально задачу выделения регистров можно сформулировать так: даны конечное множество переменных $V$,
конечное множество регистров $R$ и программа $P = \{ c_i \subset V \sqcup R \}$.
Определено отображение $live : V \rightarrow 2^P$ такое, что $v \in c \Rightarrow c \in live(v)$.
Требуется построить отображение $reg : V \rightarrow R$ такое, что $\forall v, u \in V, v \neq u, live(v) \cap live(u) \neq \emptyset \Rightarrow reg(v) \neq reg(u)$
и $\forall v \in V, r \in R \left(\exists c \in live(v), r \in c \Rightarrow reg(v) \neq r \right)$, если это возможно, а иначе сообщить о невозможности.

Программа на языке FCLang состоит из базовых блоков, которые содержат в себе линейные участки кода.
У каждого блока есть одна точка входа -- его начало.
В начале указываются переменные, которые используются как входные значения.
Точек выхода может быть несколько.
В каждой указываются условие при котором совершится переход, в какой блок совершается переход и какие переменные передаются в этот блок.

Внутри каждого блока находятся объявления переменных и инструкции.
Внутри блока могут находиться также выражения на языке Python, который выступает в качестве макроязыка.
В листинге \ref{syntax} представлен примерный синтаксис программы без конкретного описания всех выражений.

\begin{lstlisting}[caption=Синтаксис программы на FCLang, label=syntax]
<program>           №$\rightarrow$/№ <block declaration>№$^{*}$/№ <block>№$^{*}$/№
<block>             №$\rightarrow$/№ <block start> <block part>№$^{*}$/№
                                         <block exit>
<block start>       №$\rightarrow$/№ <block begin> <variable as input>№$^{*}$/№
<block exit>        №$\rightarrow$/№ pass_control
                      <block name and variables to pass>
<block part>        №$\rightarrow$/№ <variable definition> 
                       | <instruction>
                       | <conditional exit>
<conditional exit>  №$\rightarrow$/№ condition_pass <condition>
                      <block name and variables to pass>
\end{lstlisting}

Инструкции соответствуют командам ассемблера.
Для каких-то стандартных операций, например для системных вызовов, могут быть сделаны макроинструкции, которые создадут нужный набор инструкций сами.
Макроинструкции являются функциями на языке Python.
В листинге \ref{write_example} приведён пример макроинструкции для системного вызова write.

\begin{lstlisting}[caption=Пример макроинструкции для системного вызова write, label=write_example, float=h, language=Python]
def write(descriptor: Value, buffer: Value, length: Value):
    Mov(RAX, Syscalls.WRITE)
    registers = [RDI, RSI, RDX, R10, R8, R9]
    for i in range(len(args)):
        if isinstance(args[i], Variable):
            try:
                Bind(args[i], registers[i])
            except Exception:
                Mov(registers[i], args[i])
        else:
            Mov(registers[i], args[i])
    Syscall()
\end{lstlisting}

Переменная в языке FCLang ведёт себя как регистр, который отличается от всех остальных переменных и регистров, используемых одновременно с ней.
При объявлении переменной можно явно указать какому регистру она соответствует.
Задача выделения регистров в этом языке должна быть решена без выноса переменных в память.
Если это нужно сделать, то это должен будет делать пользователь.

Для создания макета языка нужно написать компилятор, входными данными которого будет программа, написанная в каком-то виде,
а выходными -- код ассемблера, который дальше может быть собран в исполняемый файл.
В этой работе был использован ассемблер NASM и код генерировался для операционной системы Linux на архитектуре x86-64.

\section{Решение}

В общем процесс решения задачи состоял из двух частей: выбора алгоритма, который будет реализован, и реализации этого алгоритма.
Далее будут приведены рассуждения, которые привели к выбору конкретного алгоритма, описание этого алгоритма и описание реализации этого алгоритма и макета языка FClang.

\subsection{Выбор алгоритма}

Для решения этой задачи был выбран алгоритм линейного сканирования.
Сделано это было по следующим причинам:
\begin{itemize}
    \item Скорость: этот алгоритм имеет линейную по числу переменных сложность, что позволит в дальнейшем использовать вставки на языке FCLang, компилируемые во время исполнения.
        При этом коэффициент линейной зависимости небольшой.
    \item Простота реализации: псевдокод самой простой версии этого алгоритма, представленный в \cite{poletto_linear_1999}, занимает всего 26 строк с выносом переменных на стек.
        Если не считать код для выноса переменной на стек, то строчек 16.
        При этом на язык Python этот код переписывается практически напрямую.
        Реализация в компиляторе FCLang сложнее, но не намного.
%    \item Глобальное выделение регитсров при помощи раскраски графов без дополнительной обработки входного кода могут давать выносы на память там, где можно обойтись без них.
%        Это было замечено в \cite{krishnamurthi_extended_2007}. Пример приведён в листинге \ref{clique_example}
    \item Граф программы, которую можно написать на языке FCLang может быть произвольным, 
        поэтому более простые алгоритмы, предложенные в \cite{hutchison_register_2005}, использовать не получится.
\end{itemize}

%\begin{lstlisting}
%switch {
%    case 0:     case 1:     case 2:
%    a = ...     b = ...     a = ...
%    b = ...     c = ...     c = ...
%    op(a, b)    op(b, c)    op(a, c)
%    break       break       break
%}
%№
%Считается, что доступных регистров 2.
%В случае глобального выделения раскраской графов a, b и c образуют клику и раскрасить её в 2 цвета нельзя.
%При этом выделить регистры можно.
%Все \texttt{case} образуют отдельные блоки и в каждом блоке живы только 2 переменные.
%/№
%\end{lstlisting}

\subsection{Уточнение алгоритма для задачи}

Алгоритм выделения регистров в этой задаче используется локальный и применяется для каждого блока отдельно.
Единственное исключение -- это переменные, используемые как входы или выходы блока.
Такие переменные между собой связаны и связанным переменным выделяется один и тот же регистр.

При выделении регистров надо учитывать не только другие переменные, но и явные использования регистров, а така же то, что некоторые инструкции (например div) могут менять конкретные регистры.
Все статьи, которые были рассмотрены при выполнении данной работы либо не упоминают это, либо в случае раскраски графов говорят, что это решается предраскрашиванием части вершин.
В этой работе это решается добавлением для каждой переменной списка регистров, которые используются в её время жизни.
Для построения этого списка используется дополнительный проход по блоку.
Псевдокод реализации представлен в листинге \ref{main_algorithm}, а в листинге \ref{interf_find} показано как ищется недопустимые регистры для переменных.

\begin{lstlisting}[caption={Алгоритм, использованный в решении}, label=main_algorithm, float, language=Python, basicstyle=\fontsize{11}{13}]
def allocate_registers(block):
    find_interfering_registers(block)
    active = []
    for var in block.variables: #№по возрастанию начала/№
        ExpireOldVars(var)
        if length(active) == R:
            Fail
        if var.register is not None:
            if var.register in var.unavailable_registers: Fail
            else: continue
        if №есть допустимый свободный регстр r для var/№:
        var.register = r
        free_registers.remove(r)
        active.insert(var) #№по убыванию конца/№
        for v in var.linked_vars:
            v.register = r

def ExpireOldVars(i):
    for j in active: #№по возрастанию конца/№
        if j.endpoint >= i.startpoint:
            return
        active.remove(j) 
        free_registers.append(j.register)

\end{lstlisting}

\begin{lstlisting}[caption={Поиск недопустимых регистров}, label=interf_find, float, language=Python]
def find_interfering_registers(block):
    active = []
    for №инструкции i по порядку от первого использования/№
            №какой-то переменной до последнего/№:
        active.add(№все переменные с началом в i/№)
        for reg in i.used_registers:
            for var in active:
                var.unavailable_registers.add(reg)
        for var in active:
            if var.last_use == i:
                active.remove(var)
\end{lstlisting}

Обычный алгоритм линейного сканирования не справится только если в какой-то момент количество живых переменных больше числа регистров.
Из-за дополнительных ограничений на допустимые регистры предложенный выше алгоритм может не справиться когда свободные регистры есть.
Более того, не справится он может тогда, когда допустимое выделение регистров есть.
Пример такого процесса представлен в листинге \ref{fail_when_possible}.
В этом примере рассматривается ситуация, когда есть только два регистра \texttt{R1} и \texttt{R2}, и алгоритм сначала присвоил переменной \texttt{v1} регистр \texttt{R1}.
В таком случае он не сможет сопоставить \texttt{v2} регистр, потому что в её интервале жизни регистр \texttt{R2} используется, а регистр \texttt{R1} уже занят.
Допустимое выделение конечно же есть: $reg(\texttt{v1}) = \texttt{R2}, reg(\texttt{v2}) = \texttt{R1}$

\begin{lstlisting}[caption={Пример кода, в котором алгоритм может не справится}, label=fail_when_possible, float=b]
op(v1)
op(v2)
op(v1)
op(R2)
op(v2)
\end{lstlisting}

Один из вариантов (частичного) исправления этой проблемы -- это в момент, когда алгоритм не справляется таким образом,
определить, как можно переставить регистры в живых переменных так, чтобы всем достался допустимый регистр.
Эту подзадачу можно визуализировать как заполнение таблицы со строками и столбцами -- переменными и регистрами,
где часть клеток вычеркнута -- недопустимые сопоставления регистров переменным.
Заполнить её надо так, чтобы в каждой строке была одна метка, а в каждом столбце не более одной метки.
Если строк меньше, чем столбцов, то тогда можно добавить строки без вычеркнутых клеток, чтобы строк и столбцов было одинаковое количество.
Тогда в каждой строке и в каждом столбце нужно поставить ровно одну метку.
Эта задача эквивалентна проверке равенства нулю перманента матрицы, построенной по таблицы следующим образом:
вычеркнутым клеткам соответствует 0, невычеркнутым 1.
На рисунке \ref{fig:permanent} приведён пример таблицы для архитектуры с 5 регистрами и соответсвующая таблице матрица.
В общем случае вычисление перманента матрицы из 0 и 1 NP-сложна \cite{valiant_complexity_1979}.
Проверка на равенство 0 же проще.
Она эквивалентна нахождению совершенного паросочетания в двудольном графе.
Для решения этой задачи есть полиномиальные алгоритмы, например тот, который предложен в \cite{chandran_practical_2011}.
Этот алгоритм реализован не был.
    \begin{figure}[h]
        \begin{minipage}[h]{0.47\linewidth}
            \begin{tabular}{*{6}{|c}|}
                \hline
                & r1 & r2 & r3 & r4 & r5\\
                \hline
                v1 & x& & x& & \\
                \hline
                v2 & x& x& x& & \\
                \hline
                v3 & & & & x&x \\
                \hline
                v4 & &x & & x&x \\
                \hline
                v5 & x& x&x & & \\
                \hline
            \end{tabular}
        \end{minipage}
        \begin{minipage}[h]{0.47\linewidth}
            $\text{perm}\left(
            \begin{array}{*{5}{c}}
                0&1&0&1&1\\
                0&0&0&1&1\\
                1&1&1&0&0\\
                1&0&1&0&0\\
                0&0&0&1&1\\
            \end{array}\right) \overset{?}{=} 0$
        \end{minipage}
        \caption{Сведение к перманенту}
        \label{fig:permanent}

    \end{figure}

\subsection{Реализация}
Реализация написана на языке Python.
Результатом компиляции является код на языке ассемблера NASM.
Базовые блоки реализованы как блоки кода обёрнутые в \texttt{with} выражение.
Базовый блок представляет собой последовательность инструкций, которые исполняются линейно.
Внутри базового блока не может быть ветвления или циклов,
но возможно выходить из него раньше, чем он закончится.
Пример написанного блока представлен в листинге \ref{block_example}.

Базовые блоки представлены классом \texttt{Def}.
В представителе этого класса хранится список инструкций, список переменных,
отдельный список переменных, в которых на входе есть значение (подобно аргументам функции),
список блоков с наборами переменных, которые нужны для перехода в другие блоки.

Инструкции реализованы как конструкторы класса.
Создание объекта класса инструкции добавляет её и её операнды в соответствующие списки блока.

Инструкции наследуются от базового класса \texttt{Instruction},
и логика, нужная для базовой инструкции, находится в нём.
Наследники только уточняют название в языке ассемблера NASM, число операндов, тип действий над ними.
Пример реализации простой инструкции представлен в листинге \ref{instruction_example}.

\begin{lstlisting}[caption={Пример блока кода}, label=block_example, float, language=Python]
with loop:
    number = Variable()
    number.set_as_input()
    Add(number, -1)
    condition_pass(Flag.Zero, False, (print, [number]))
    pass_control((finale, []))
\end{lstlisting}

\begin{lstlisting}[caption={Пример определения простой инструкции}, label=instruction_example, float, language=Python]
class Imul(Instruction):
    operand_count = 2
    operand_actions = [Action.READWRITE, Action.READ]
    name = "imul"
\end{lstlisting}

\section{Заключение}
В этой работе была реализована система выделения регистров, основанная на алгоритме линейного сканирования.
Так же был сделан макет языка FCLang, на котором можно писать примитивные программы, используя при этом уже переменные.

Реализованный алгоритм может не справиться с выделением регистров, но в данный момент непонятно насколько это большое ограничение.
Стоило бы попробовать реализовать на языке FCLang какой-нибудь большой по коду алгоритм и проверить,
насколько <<неоптимальность>> алгоритма влияет на компилируемость кода.

В дальнейшем в реализации языка стоит добавить поддержку векторных инструкций,
потому что они важны для оптимизации и потому что, по крайней мере в архитектуре x86\_64,
только на них происходят вычисления с плавающей запятой.

У языка FCLang нет формального описания и реализации.
Над этим точно можно ещё работать.

\newpage

\bibliographystyle{ugost2008}
\bibliography{fclang_register_allocation}


\end{document}
