% !TeX spellcheck = ru_RU
\documentclass[a4paper,14pt]{extarticle}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{hyperref}

\usepackage{xcolor}

\usepackage{indentfirst}
\usepackage[left = 20mm, right = 10mm, top = 20mm, bottom = 20mm]{geometry}
\usepackage[indent=1.25cm]{parskip}
\renewcommand{\baselinestretch}{1.5}

\newtheorem{theorem}{Теорема}

\lstset{label=Листинг, tabsize = 2, basicstyle=\ttfamily, captionpos=b, escapeinside={№}{/№}}

\author{Борисенков Никита}



\begin{document}

\begin{titlepage}
    \newpage
    \begin{center}
        Московский государственный университет имени M.В. Ломоносова
        Механико-математический факультет\\
        Кафедра вычислительной математики \\
    \end{center}

    \vspace{8em}

    \begin{center}
        \Large Курсовая работа \\
    \end{center}

    \vspace{2em}

    \begin{center}
        \textsc{\textbf{}}
    \end{center}

    \vspace{20em}



    \newbox{\lbox}
    \newlength{\maxl}
    \setlength{\maxl}{\wd\lbox}
    \hfill\parbox{13cm}{
        \hspace*{5cm}\hspace*{-5cm}Студент: \qquad\qquad\hbox to \maxl{Борисенков Никита Николаевич\hfill}\\
        \hspace*{5cm}\hspace*{-5cm}Преподаватель: \hbox to \maxl{ С.н.с Кривчиков Максим Александрович}\\
        \\
        \hspace*{5cm}\hspace*{-5cm}Группа:\qquad\qquad $\;\:$ \hbox to\maxl{410}\\
    }


    \vspace{\fill}

    \begin{center}
        Москва \\2025
    \end{center}

\end{titlepage}
\newpage

\section*{Введение}

Задача выделения регистров заключается в сопоставлении переменным или символическим регистрам программы, физических регистров.
Первых может быть практически неограниченное количество, а число вторых жёстко ограничено целевой архитектурой процессора.
В таких популярных архитектурах как ARM64 и x86-64, число доступных физических регистров составляет регистров 32 и 16 (если не считать векторные).
Эта задача естественно возникает при создании компиляторов для различных языков программирования.
В 
В данной работе описан процесс создания системы выделения регистров для минималистичного низкоуровневого языка, предложенного в \cite{____2023}.

\section{Результаты известных исследований}

Задача выделения регистров является важной частью процесса компиляции программ.
Самым известным способом решения этой задачи является сведение её к задаче раскраске графа пересечения времён жизни переменных.
Эта идея была предложена в 1981 году в \cite{chaitin_register_1981}.
Для произвольных графов задача раскраски является NP-сложной и в \cite{chaitin_register_1981} показано,
что для любого графа можно написать программу, задача выделения регистров которой будет сводиться к раскраске этого графа.

Для алгоритма, сформулированного в \cite{chaitin_register_1981}

В статье \cite{hans_l_bodlaender_linear-time_1997} показано, что если число регистров фиксировано и не производится вынос переменных на стек,
то для <<структурированных>> программ существует линейный по количеству вершин и рёбер в графе алгоритм выделения регистров.
Структурированность в данной статье означает отсутствие команд перехода в произвольную точку программы.
Из структурированности следует ограниченная древесная ширина графов, а для таких графов существует линейный алгоритм определения возможности и нахождения раскраски.
При этом сложность алгоритма получается экспоненциально зависящей от числа регистров.

Другое развитие этого метода представлено в статье \cite{hutchison_register_2005}, 
авторы которой замечают, что графы большинства программ являются хордовыми.
А для хордовых графов существует линейный по числу рёбер алгоритм нахождения раскраски, который они и реализуют. 
Получившийся алгоритм не итеративный, в отличие от классического, основанного на раскраске произвольных графов,
линейный в случае хордовых графов и по качеству кода сопоставим с классическим.
{\color{red}
    Под классическим здесь имеется ввиду iterated register coalescing. Я, во-первых, не нашёл, как его перевести,
    а во-вторых как-то не читал про него статьи, потому что кажется, что это то, что я точно не буду делать.
    Стоит ли найти что-то и написать про него сюда?
}

Другой известный способ выделения регистров -- это линейное сканирование (linear scan), предложенный в статье \cite{poletto_linear_1999}.
Этот алгоритм не использует графовое представление пересечений интервалов жизни переменных, а работает с ними напрямую.
Сложность этого алгоритма линейна по количеству переменных, что является значительным преимуществом по сравнению с раскраской графа,
и позволяет его использовать в случаях, когда время компиляции важно (например, JIT-компиляция).
Основным недостатком является худшее, по сравнению с раскраской графа, качество генерируемого кода, то есть полученные программы работают медленнее.

В статье \cite{krishnamurthi_extended_2007} замечено, что задача выделения регистров не эквивалентна напрямую задаче раскраски графа.
Из последней следует первая, но не наоборот.
В добавок к этому авторы указывают на такие недостатки алгоритмов раскраски графа,
как нелинейность и необходимость выделять память для него,
пропорциональную в худшем случае $n^2$, а в среднем $n^{1,5}$, где n -- это число переменных.
Авторы предлагают алгоритм, основанный на линейном сканировании, который этими недостатками не обладает.
Более того, этот алгоритм работает быстрее и в большинстве случаев, на которых авторы его проверяли, генерирует более качественный код.

{\color{red}
    Есть ещё алгоритм, который в llvm используется.
    Я смотрел как он работает, но не искал статей.
    В основном, потому что он очень сильно основывается на разрезании интервалов жизни и перекладывании регистров, если нужно
}

\section{Постановка задачи}

\section{Решение}

\section{Заключение}

\newpage

\bibliographystyle{ugost2008}
\bibliography{fclang_register_allocation}


\end{document}
